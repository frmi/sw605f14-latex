\section{The Authentication Animation}
The first time we attempted to start Launcher, we found that it was unable to do so, as the application crashed, and logged an \lstinline{OutOfMemoryError}.
It turned out that the problem was caused by an animation in the \textit{Authentication} activity, implemented as an instance of the Android class \lstinline{AnimationDrawable}, a class designed to create animations from a sequence of images.
According to the documentation for Android \cite{androidreference}, the existing implementation was technically correct, but the error persisted.

After some investigation we found that when the instance of \lstinline{AnimationDrawable} is created, it loads the entire sequence of images into the main memory at once.
The images are compiled with the application in the compressed Portable Network Graphics (PNG) format.
However, as they are loaded, Android converts each image to a 32-bit bitmap, which is 4 bytes per pixel, making the images take up about 20 times more space, and the entire animation use about 40 MB of memory. We hypothesized that this was the source of the \lstinline{OutOfMemoryError}.

Our solution to this problem was to create a new class which simulates the behaviour of \lstinline{AnimationDrawable}, but uses the original PNG images.

The original \lstinline{AnimationDrawable} was set up as shown in \Cref{lst:animationDrawable}. \lstinline{R.animator.instruct_ani} is a list of images combined with a constant for each image, which determines the duration each image should be shown.

\begin{lstlisting}[caption={The original animation implementation, using \lstinline{AnimationDrawable}.},label={lst:animationDrawable}]
final ImageView instructImageView = (ImageView) findViewById(R.id.animation);
instructImageView.setBackgroundResource(R.animator.instruct_ani);

instructImageView.post(new Runnable(){
    @Override
    public void run(){
        AnimationDrawable anim = (AnimationDrawable) instructImageView.getBackground();
        anim.start();
    }
});
\end{lstlisting}

Our class, simulating \lstinline{AnimationDrawable}, has the method \lstinline{play()}, shown in \Cref{lst:methodPlay}, where the input parameter \lstinline{pFrameNo} is the initial image in a static array which contains all the images used in the animation. 
With this method we only keep one image in memory at all times, since we are changing the image for each run of the \lstinline{play} method and there by avoid an out of memory error.
\begin{lstlisting}[caption={Our method for playing an animation based on a set of images.},label={lst:methodPlay}]
private void play(final int pFrameNo){
    mImageView.postDelayed(new Runnable(){
        @Override
        public void run() {                    
            mImageView.setImageResource(mFrames[pFrameNo]);

            if(pFrameNo == mLastFrameNo)
                play(0);
            else
                play(pFrameNo + 1);
        }
    }, mDuration);
}        
\end{lstlisting}

After we switched the old \lstinline{AnimationDrawable} implementation with our new class, the problem disappeared.