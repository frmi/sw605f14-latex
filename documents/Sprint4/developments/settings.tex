\subsection{Finishing up the ``Apps'' Pane}

The \textbf{Apps} pane is improved in a number of ways:
\begin{itemize}
\item Choosing a new profile loads the settings of the chosen user.
This was done by finishing this instances \lstinline|SettingsActivity| and then starting up a new instance of it with the new user as \lstinline|currentUser|.
\item When having loaded applications in \lstinline|GirafFragment| and \lstinline|AndroidFragment| once, selecting the panes subsequently does not cause the fragment to reload applications. This is a huge optimization.

In order to achieve this behaviour of the fragments we take advantage of the fragment life cycle in Android. This means that when a fragment is left Android marks the fragment as paused, and if it has not been used for some time Android will run its garbage collector and destroy the fragment. But if you return to the fragment before it is destroyed the views are still visible. Therefore we simply check if the layout in which the applications are contained is already instantiated, if this is the case we use the existing else we instantiate it over again.

\end{itemize}

\subsection{ViewHolder Design Pattern}
As mentioned in the third sprint in \cref{sec:settingslistadapter}, the \lstinline|getView()| implemented in the \lstinline|SettingsListAdapter| class is not considered to be optimal.
In this sprint, it is chosen to refactor this method to overcome the defiances found, by implementing the \textit{ViewHolder} design pattern, which is an Android best practice of handling multiple views in an \lstinline|AdapterView|.
It is thus a way of improving the efficiency of the code, but it also enhances the readability for handling shadows for each list item (\lstinline|AdapterView|).

The ViewHolder pattern is at its name suggest, a class that holds a reference to a \lstinline|View|.
The \lstinline|ViewHolder| for \lstinline|getView()| is shown in \cref{lst:viewholder}.

\begin{lstlisting}[caption={The intent filter and action a \giraf application has to provide to be shown in settings.}, label={lst:viewholder}]
private static class ViewHolder {
  public ImageView appIcon;
  public TextView appName;
  public View shadowTop;
  public View shadowBottom;
  public View shadowRight;
}
\end{lstlisting}

The essence of the pattern is to use it when a \lstinline|convertView| is being inflated; 
if the \lstinline|convertView| is \lstinline|null|, we inflate the view and instantiates a \lstinline|holder = new ViewHolder()| and obtains a reference to each of the views it contain.
This is exemplified in \lstinline|lst:viewholder:getview|.
Then, to be able to get the \lstinline|holder| back when \lstinline|getView()| is called again for the same \lstinline|convertView|, the view is tagged with the \lstinline|holder| object to save a reference to the ViewHolder.
Restoring the \lstinline|holder| object is simply done if \lstinline|convertView| is not \lstinline|null|, meaning that it has already been inflated but recycled for performance reasons.

\begin{lstlisting}[caption={Excerpt of the refactored \lstinline|getView()| method in \lstinline|SettingsListAdapter|.}, label={lst:viewholder:getview}]
ViewHolder holder;

if(convertView == null) {
  convertView = mInflater.inflate(R.layout.settings_fragment_list_row, null);

  holder = new ViewHolder();
  holder.appIcon = (ImageView)convertView.findViewById(R.id.settingsListAppLogo);
  holder.appName = (TextView)convertView.findViewById(R.id.settingsListAppName);
  holder.summary = (TextView)convertView.findViewById(R.id.settingsListSummary);
  holder.shadowTop = convertView.findViewById(R.id.settingsListRowShadowBelow);
  holder.shadowBottom = convertView.findViewById(R.id.settingsListRowShadowAbove);
  holder.shadowRight = convertView.findViewById(R.id.settingsListRowShadowRight);
  convertView.setTag(holder);
}
else
  holder = (ViewHolder)convertView.getTag();
\end{lstlisting}

Of course the use of the ViewHolder pattern is most noticeable in situations where many list items are handled.
None the less, it reduces the amount of calls made to \lstinline|findViewById()|, which iteratively searches the view hierarchy for the specified id.
Since creation of views is expensive in Android, and considering the many views contained within each \lstinline|convertView| and the amount of times \lstinline|getView()| is called, the calls made to  \lstinline|findViewById()| is dramatically reduced.\cite{understandingAdapters}

As also mentioned in \cref{sec:settingslistadapter}, the initial implementation had problems with duplicate code for setting the visibility of the shadows.
This is also by using the ViewHolder pattern, since it makes it possible to always hold a reference to the views. 
Therefore, the three methods is merged into one just taking a view and whether to show or hide it as input.

\thilemann[inline]{Conclude on this in Sprint End!}

\subsection{Background Loading of Applications}\label{sec:sprint4:dev:loadapplicationtask}
There are three \lstinline!View!s that get populated by applications in the \launcher project:

\begin{itemize}
\item The container in \lstinline!GirafFragment!, populated by \giraf applications only
\item The container in \lstinline!AndroidFragment!, populated by Android applications only
\item The main container in \lstinline!HomeActivity!, populated by both Android and \giraf applications
\end{itemize}

Since all three \lstinline!View!s needed some time to load the applications, it was deemed important to populate them off the UI thread.
Furthermore, populating all three \lstinline!View!s in the same way would also simplify the code.
Thus, the class \lstinline!LoadApplicationTask! has been created to load applications. 
It inherits from \lstinline!ASyncTask! and must therefore implement three methods:

\begin{itemize}
\item \lstinline!onPreExecute()! is called before the task is carried out and runs on the UI thread.
\item \lstinline!doInBackground()! should contain the task to be carried out and will carry it out in a background thread.
\item \lstinline!onPostExecute()! is called after the task has been carried out and runs on the UI thread.
\end{itemize}

We override \lstinline!onPreExecute()! and \lstinline!onPostExecute()! to start and stop showing a loading animation, respectively.

The method in \lstinline!LauncherUtility! used to populate a view with applications, \lstinline!loadApplications()! is deleted, and the contents are moved into \lstinline!doinBackground()!.
Since the views can only be manipulated in the UI thread, we add the applications as views to a list of views.
Once \lstinline!doinBackground()! finishes, \lstinline!onPostExecute()! the applications are added from the list to the target view. 
The constructor of \lstinline!LoadApplicationTask! is also adjusted to take as parameter all the information needed to populate a given view.

The observer which is observing new applications are are responsible for loading new applications, and is described in \cref{sec:sprint3:observing}, must be paused while added applications and restarted afterwards.
This happens in \lstinline!onPreExecute()! and \lstinline!onPostExecute()! respectively.

Because of the differences in the three classes which are loading applications, namely \lstinline!HomeActivity!, \lstinline!GirafFragment! and \lstinline!AndroidFragment!, we need to create a specialized version of the load application task for each class.
The reasons relate to the responsibility of the three classes;
\begin{itemize}
	\item Home activity has the responsibility to open applications when added,
	\item the GIRAF fragment and android fragment has the responsibility for marking applications as selected.
\end{itemize}
Even though the two fragments has the same responsibility the differ in the fact that the GIRAF fragment handles applications from the \giraf system and thereby does changes in the local database.
Whereas the android fragment handles selection of other Android applications, these selections are stored on the device.
An example of how one of these specialised tasks is shown in \cref{lst:derivedlat}.

To start the task for loading applications the observer is using a specialised version of the following code snippet.
\begin{lstlisting}[caption={A simplified code snippet for starting loading applications into a view.}, label={lst:simplelat}]
LoadApplicationTask lat = new LoadApplicationTask(context, currentUser, guardianUser, targetView, iconsize, onClickListener);
loadApplicationTask.execute(applicationsToLoad);
\end{lstlisting}
