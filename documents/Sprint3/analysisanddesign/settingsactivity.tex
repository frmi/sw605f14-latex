\subsection{Adding Settings to \giraf}\label{sec:sprint3:designsettings}
The idea behind providing a way to change settings from \launcher for both itself, but also other \giraf applications, is to create a streamlined and uniform user interface for changing settings across the entire project.
This section discusses how to design the architecture of what will be an activity implemented in the context of \launcher, to contain the settings.

\subsubsection{Choosing Between Prototypes}
As discussed in \cref{sec:sprint2:secondmeeting}, the customers agreed that settings should be accessible through two methods:

\begin{itemize}
	\item A dialogue box in each individual application, containing only settings relevant to that specific application (as seen in \cref{fig:appsettingsprototype}). 
	The dialogue box should be displayed when the user presses a button identical throughout all \giraf applications, making it easier for users to find.
	\item A unified settings activity, where the user has immediate access to all settings for all \giraf applications, which should be a part of the \launcher. 
	Besides settings of individual applications, it should also contain settings available to a per-user basis, e.g. which applications the user should be allowed access to.
\end{itemize}

It is immediately apparent that for making both these approaches work in parallel, a single plan for how user settings are handled throughout the \giraf project is needed. 
In the following paragraph this plan is described.

\paragraph{Concept}
It is decided that the settings system should consist of four components, to be implemented separately:

\begin{itemize}
	\item The unified settings activity should be implemented as a part of \launcher, and therefore the implementation of this component naturally falls to ourselves. 
	Excluded from this task is the settings of the individual applications.
	\item A dialogue box able to contain the settings for an arbitrary \giraf application. Included in this is a standard button for launching the dialogue box. 
	As this User Interface component is useful to all applications, it should be implemented by the group responsible for the \giraf GUI library.
	\item A set of settings for each \giraf application.
	As these sets may vary widely in content and complexity from application to application, and furthermore may change along with their associated applications over time, these should be defined and implemented by the individual project groups. 
	\item A method for storing the settings in the database, allowing the users to easily use the same settings across several devices. 
	This should be implemented by the database group. 
\end{itemize}

\thilemann{Last item regarding remotedb - add somewhere that this is currently only done locally per device.}

\paragraph{Technical Analysis} \thilemann[inline]{Note-to-self: remember to look at this...}
The big challenge of implementing the above concept, is how to allow applications other than \launcher to access the settings interface running in the context of \launcher.

Our initial idea was to ask each group to create a fragment with their settings layout within their own activity, which our settings activity would then be able to load into the unified settings activity.
This would isolate the responsibilities of each group, and keep overall complexity to a minimum.
Although there is a official way for custom class loading\cite{customClassLoading}, it is complex and it will make the coupling of the launcher and the other android applications very tight.
Additionally it is difficult to make the loading of custom classes dynamic the name of the class to be loaded has to be known.
The method of custom class loading is intendet to be used when a project exeeds 64.000 method references which is the limit of the Dalvik executable which is the executable of a compiled android application.

To simplify this, \launcher could include all other projects as dependencies when compiling, but this would have made the \launcher project unnecessary bloated and difficult to work with.

Another possibility was make the individual applications implement an interface, where a function would add the application's setting-widgets to a given view.
While Android provides facilities for inter-application communication through its \textit{Broadcast} mechanism\cite{broadcastReceiver}, this requires all the involved applications to be running.
This is not an acceptable condition in this situation. 

The design which has been chosen is using Intent Filters, which is an Android feature that allows applications to communicate activity to activity, by add an action element with a certain action string\cite{intentFilter}.
With this method we will examine all applications on the device, looking for an intent filter with a certain action string.
If an application implements this intent filter, we know that the application has a settings activity which can be added to the list of settings.

With this design it is possible to load settings from other applications as fragments in our application, we will have to start the application and their settings activity. However, this only simplifies the complexity about saving the settings, since if we load their settings as a fragment we load it in context of our application. 
We would then have to save it again in their context or we would have to figure out a solution for them to load the settings from our context.