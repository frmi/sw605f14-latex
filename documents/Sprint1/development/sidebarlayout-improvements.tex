\subsection{Sidebar Layout Re-factoring}
\thilemann{Check naming of sidebar (vertical bar or whatever we call it)}
The behaviour of the drawer (as described in \cref{sec:drawer:behaviour}) has the unfortunate effect on the list of applications that it pushes their containing view to the right as the drawer is dragged open.
This is caused by the view (\lstinline|HorizontalScrollView|) having the  \lstinline{android:layout_toRightOf} parameter set to be placed to the right of the vertical bar in the layout XML files, which makes its position adjust automatically to the newest rightmost position of the vertical bar each time the bar is moved, effectively pushing the icons of the screen.

The improved implementation includes restructuring all parts of the XML file defining the layout of the home activity, making it adapt to devices with various screen sizes (and pixel density).
Despite of the layout elements not being used correctly and thus not following Android design guidelines, the main issue lies in the fact that many parameters such as heights and widths are set at compile-time through a class containing mostly static fields.
The result is that the layout does not adapt to more than device it has been designed for, which is not viable if fx the customers chooses to replace their current devices.

\subsubsection{Restructuring Layout of the Drawer}\label{sec:sidebarlayout:xml}
To avoid the icons being pushed outside the screen, the layout for the drawer is restructured so its elements are contained within a custom view called \lstinline|SideBarLayout|.
This ensures that the animation and layout hierarchy can be controlled more effectively, making the drawer being drawn on top of other layout elements.
The custom view is further described in \cref{sec:siebarlayout:java}.
\Cref{lst:sidebarlayout} shows the elements of the XML layout with most attributes omitted.

\begin{lstlisting}[caption={Structure of the XML layout of the drawer.},label={lst:sidebarlayout}, language=XML]
<dk.aau.cs.giraf.launcher.layoutcontroller.SideBarLayout android:id="@+id/SideBarLayout" android:layout_marginLeft="-400dp">

<RelativeLayout android:id="@+id/HomeDrawer" android:layout_width="400dp">
<GridView android:id="@+id/appcolors" />
</RelativeLayout>

<RelativeLayout android:id="@+id/HomeBarLayout">
<dk.aau.cs.giraf.gui.GWidgetProfileSelection />
<dk.aau.cs.giraf.gui.GButtonSettings />
<dk.aau.cs.giraf.gui.GWidgetLogout />
</RelativeLayout>

</dk.aau.cs.giraf.launcher.layoutcontroller.SideBarLayout>
\end{lstlisting}

The negative margin of 400dp defined on line 1 effectively hides the \lstinline|SideBarLayout| when the home activity is just started, revealing only the \lstinline|HomeBar|.
Since it is placed next to the \lstinline|GridView| with the id of \textit{appcolors} and this view has the same width as the negative margin defined on \lstinline|SideBarLayout|, it is the only visible element; giving the impression of a closed drawer.

\subsubsection{Extending an Android View Class}\label{sec:siebarlayout:java}


\begin{lstlisting}[caption={Extending the Android \lstinline|RelativeLayout| class.},label={lst:sidebarlayout:java}]
public class SideBarLayout extends RelativeLayout {
  
  public boolean isSideBarHidden = true;
  
  /* Public constructors omitted for brevity */
  
  @Override
  protected void onAnimationStart() {
    super.onAnimationStart();
    this.bringToFront();
  }
  
  @Override
  protected void onAnimationEnd() {
    super.onAnimationEnd();

    SideBarLayout.LayoutParams params = (SideBarLayout.LayoutParams) this.getLayoutParams();
    RelativeLayout homeDrawer = (RelativeLayout) findViewById(R.id.HomeDrawer);

    if (isSideBarHidden) {
      params.leftMargin = homeDrawer.getLeft();
      isSideBarHidden = false;
    } else {
      params.leftMargin -= homeDrawer.getMeasuredWidth();
      isSideBarHidden = true;
    }
    this.setLayoutParams(params);
  }
}
\end{lstlisting}

\subsubsection{Animating the Drawer}


\begin{lstlisting}[caption={Using the animation of the drawer from the home activity.},label={lst:draweranimation:homeactivity}]
private void placeDrawer(){
  int to;

  if(mSideBarView.isSideBarHidden)
    to = mHomeDrawerView.getWidth();
  else
    to = -mHomeDrawerView.getWidth();

  // then animate the view translating from (0, 0)
  TranslateAnimation ta = new TranslateAnimation(0, to, 0, 0);
  ta.setDuration(500);
  if(!mDrawerAnimationRunning){
    mSideBarView.startAnimation(ta);
    mDrawerAnimationRunning = true;
  }

  ta.setAnimationListener(new TranslateAnimation.AnimationListener() {

    @Override
    public void onAnimationStart(Animation animation) {
      // Sets the left margin of the scrollview based on the width of the homebar
      mAppsScrollViewParams = new RelativeLayout.LayoutParams(mAppsScrollView.getLayoutParams());
      mAppsScrollViewParams.leftMargin = mHomeBarLayout.getWidth();
      mAppsScrollView.setLayoutParams(mAppsScrollViewParams);
    }

    @Override
    public void onAnimationRepeat(Animation animation) {
    }

    @Override
    public void onAnimationEnd(Animation animation) {
        mDrawerAnimationRunning = false;
    }
  });
}
\end{lstlisting}





