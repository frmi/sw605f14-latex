\subsection{Refactoring the Drawer Layout}
The behaviour of the drawer (as described in \cref{sec:drawer:behaviour}) has the unfortunate effect on the list of applications that it pushes their containing view to the right as the drawer is dragged open.
This is caused by the view (\lstinline|ScrollView|) having the  \lstinline{android:layout_toRightOf} attribute set to be placed to the right of the vertical bar in the layout XML files, which makes its position adjust automatically to the newest rightmost position of the vertical bar each time the bar is moved, effectively pushing the icons of the screen.

The improved implementation includes restructuring all parts of the XML file defining the layout of the home activity, making it adapt to devices with various screen sizes (and pixel density).
Despite of the layout elements not being used correctly and thus not following Android design guidelines, the main issue lies in the fact that many parameters such as heights and widths are set at compile-time through a class containing mostly static fields.
The result is that the layout does not adapt to more than device it has been designed for, which is not viable if the customers, as an example, choose to replace their current devices.

\subsubsection{Restructuring Layout of the Drawer}\label{sec:sidebarlayout:xml}
\jesper{Find a better title. It should not sound exactly like the subsection title.}
To avoid the icons being pushed outside the screen, the layout for the drawer is restructured so its elements are contained within a custom view called \lstinline|DrawerLayout|.
This ensures that the animation and layout hierarchy can be controlled more effectively, making the drawer being drawn on top of other layout elements.
%The custom view is further described in \cref{sec:siebarlayout:java}. % udkommenteret da det refere til en anden udkommenteret section
\Cref{lst:sidebarlayout} shows the elements of the XML layout with most attributes omitted.

\begin{lstlisting}[caption={Structure of the XML layout of the drawer.},label={lst:sidebarlayout}, language=XML]
<dk.aau.cs.giraf.launcher.layoutcontroller.DrawerLayout android:id="@+id/DrawerView" android:layout_marginLeft="-400dp">

<RelativeLayout android:id="@+id/DrawerContentView" android:layout_width="400dp">
<GridView android:id="@+id/appcolors" />
</RelativeLayout>

<RelativeLayout android:id="@+id/SidebarView">
<dk.aau.cs.giraf.gui.GWidgetProfileSelection />
<dk.aau.cs.giraf.gui.GButtonSettings />
<dk.aau.cs.giraf.gui.GWidgetLogout />
</RelativeLayout>

</dk.aau.cs.giraf.launcher.layoutcontroller.DrawerLayout>

<ScrollView android:id="@+id/appScrollView"/>
\end{lstlisting}

Notice the \lstinline|ScrollView| on the last line in \Cref{lst:sidebarlayout}.
The before mentioned \lstinline{android:layout_toRightOf} attribute have been removed, to keep it from being pushed out of the screen.
The negative margin of 400dp defined on line 1 effectively hides the \lstinline|SideBarLayout| when the home activity is just started, revealing only the \lstinline|HomeBar|.
Since the \lstinline|HomeBar| is placed next to the \lstinline|GridView| (in the layout file) with the id of \lstinline!appcolors! and this view has the same width as the negative margin defined on \lstinline|SideBarLayout|, it is the only visible element; giving the impression of a closed drawer.

% \subsubsection{Extending an Android View Class}\label{sec:siebarlayout:java}
% In \cref{lst:sidebarlayout}, the \lstinline|dk.aau.cs.giraf.launcher.layoutcontroller.SideBarLayout| is a reference to the implementation of this class as seen in \cref{lst:sidebarlayout:java}.
% The main reason for not using a \lstinline|RelativeLayout| is that when overriding the \lstinline|onAnimation| methods from the containing activity, is is not being drawn properly, making the drawer flicker when animated.
% Using a custom implementation, it is possible to extend the layout with tailor-made functionality to obtain the desired behaviour.

% \begin{lstlisting}[caption={Extending the Android \lstinline|RelativeLayout| class.},label={lst:sidebarlayout:java}]
% public class SideBarLayout extends RelativeLayout {

%   public boolean isSideBarHidden = true;
  
%   @Override
%   protected void onAnimationStart() {
%     super.onAnimationStart();
%     this.bringToFront();
%   }
  
%   @Override
%   protected void onAnimationEnd() {
%     super.onAnimationEnd();

%     SideBarLayout.LayoutParams params = (SideBarLayout.LayoutParams) this.getLayoutParams();
%     RelativeLayout homeDrawer = (RelativeLayout) findViewById(R.id.HomeDrawer);

%     if (isSideBarHidden) {
%       params.leftMargin = homeDrawer.getLeft();
%       isSideBarHidden = false;
%     } else {
%       params.leftMargin -= homeDrawer.getMeasuredWidth();
%       isSideBarHidden = true;
%     }
%     this.setLayoutParams(params);
%   }
% }
% \end{lstlisting}

% The code (\cref{lst:sidebarlayout:java}) is of trivial character, but makes the implementation of the drawer a lot easier, since it makes it responsible for its placement after animating.
% An Android \lstinline|TranslateAnimation| does not animate the view, but obtains a bitmap of the view which is then animated.
% Without controlling its position after initiating the animation, it would pop back to its original position.
% The position of the \lstinline|SideBarLayout| is set relative to the position of the \lstinline|HomeBar| when \lstinline|onAnimationEnd()| is called.
% \lstinline|this.bringToFront()| simply ensures that the view is rendered on top of other layouts, making it slide on top of them.
% The public field \lstinline|isSideBarHidden| is used to calculating if the drawer should be animated to either opened or closed state.% (as seen in \cref{lst:sidebarlayout:java,lst:draweranimation:homeactivity}).

% \subsubsection{Animating the Drawer}
% The animation of the drawer is started from a touch listener located on the \lstinline|HomeBar| in \lstinline|HomeActivity|.
% \Cref{lst:draweranimation:homeactivity} shows an excerpt of the code that gets called to start the animation.

% \begin{lstlisting}[caption={Excerpt of \lstinline|placeDrawer()| method from the home activity.},label={lst:draweranimation:homeactivity}]
% int to;

% if(mSideBarView.isSideBarHidden)
%     to = mHomeDrawerView.getWidth();
% else
%     to = -mHomeDrawerView.getWidth();

% // Animate the drawer (fromX, toX, fromY, toY)
% TranslateAnimation ta = new TranslateAnimation(0, to, 0, 0);
% ta.setDuration(500);
% if(!mDrawerAnimationRunning){
%   mSideBarView.startAnimation(ta);
%   mDrawerAnimationRunning = true;
% }

% ta.setAnimationListener(new TranslateAnimation.AnimationListener(){
%   @Override
%   public void onAnimationStart(Animation animation){
%     mAppsScrollView.setLeft(mHomeBarView.getWidth());
%   }
%   ...
% });
% \end{lstlisting}

% The member \lstinline|to| is used to decide which direction on the x-axis the view should be animated when instantiating a new \lstinline|TranslateAnimation|.
% Its constructor takes values relative to its current position, which is why all but one parameter is 0.
% The parameter not 0 is the position the animation should animate to on the x-axis.
% Before starting the animation, the left margin of \lstinline|mAppsScrollView| is set to the rightmost position of the \lstinline|HomeBar| to make the \lstinline|ScrollView| stay at its current position.